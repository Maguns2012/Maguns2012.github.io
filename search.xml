<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CoreAnimation-基础补充]]></title>
    <url>%2F2017%2F07%2F18%2FCoreAnimation-%E5%9F%BA%E7%A1%80%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[新的格式化方式]]></title>
    <url>%2F2017%2F06%2F28%2F%E6%96%B0%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原文链接点击跳转 原文标题是Swift 4 Codable, JSON Handling Made Easy 副标题 Data Can Make You Cry（有没有这么激动） 现在可以用很少的代码实现json的编译与反编译了。虽然有大量的第三方库可以实现该功能，但是Swift系统库也实现了该功能。下面了解一下新的协议。 需求 现在有一个小需求，我们需要发送json数据并释放并释放内存。在Swift3.0时我们需要写大量的工厂代码去进行编译与反编译。现在，当数据结构需要改变或者必须改变呢？我们需要每次重写代码。 对于如此时尚的语言，有没有更好的解决方式？ 解决方案Swift给出了更好的解决方案，更好的是，仅需一个字。Codable继承了2个协议的一个字，仅仅需要继承Codable并通过创建的编译或反编译对象，编译器会很优秀的完成映射操作。 第一步假设我们有个Person的结构体，需要通过编译器实现结构体到json数据的编译，第一步当然是创建结构体。 Struct Person : Codable{ enum Gender:String,Codable { case Male,Female,Alien } var name : String var userName : String var gender:[Gender] } 结构体包含一些变量，像是name,username,gender是一个枚举，用于表示有限的有限制的数据选项。创建一个Person的实例对象 let person = Person(name : &quot;Peter&quot;,userName : &quot;pwitham&quot;,gender :[.Alien]) 编译为json在实现转化之前，需要创建JSONEncoder实例对象，通过创建的数据对象保存编译实例，这里通过String展示对应的数据 let jsonencoder = JSONEncoder() let jsonData = jsonencoder.encode(person) let stringData = String(data : jsonData, encoding : .utf8) printf(stringData) 反编译json在反编译之前，需要创建JSONDecoder实例对象，通过该对象反编译并创建一个容器保存数据。最后打印，查看数据结构 let jsonDecoder = JSONDecoder() let decodePerson = try jsonDecoder.decoder(Person.self,from:jsonData) printf(decodePerson) 包装现在该协议已经翘首以盼。当修改结构体时，Swift4会自动映射转换成对应的数据结构。 在众多第三方库中，也许这才是最好的选择。 （不是很同意，我使用第三方只是为了比较全面的数据类型转化，鬼知道后台传过来的数据到底是什么格式的）]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么是闭包]]></title>
    <url>%2F2017%2F06%2F18%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[原文链接国外友人的博客 单纯的我以为有底层代码可看了，结果。。。说好的只讨什么是闭包。以下部分使用“闭包”代替原文中的”Closure” 名字里包含了什么？ 如果一门语言可以实现命名，你就可以通过实现中找到命名原因。他们在命名的时候肯定是有目的的。所以当你思考“为什么这么命名”的问题时，你可能就会理解语法的特点和概念。 为什么是闭包 现在交换：真是提问“为什么”这个问题 Swift 底层是开源的，经常有一些描述在包含在命名里。但是闭包在Swift开源之前就已经存在了。这可导致，我真的找不到太多的论点说明闭包问什么叫“闭包”。 分拆开闭包（感谢，thesaurus.com！） 所以…我们将开始通过讨论以表达什么是闭包。 官方文档中闭包的描述“Closures are self-contained blocks of functionality that can be passed around and used in your code.”（Apple Developer Docs）。需要深究的是——为什么叫他们”functions”?? 尽我所能的拆开这个词，当我在同义词网站查询闭包的近义词时，我获取到这些 Plug Seal Cork 在这些闭包的近义词词都是好像都是围绕着…某些东西。 好吧，那么闭包围绕着什么？好问题！ 剪短的回答，变量 Variables 当在互联网上仔细阅读什么是闭包的时候，不可避免的或出现通过Apple’s 模拟器，等相关引用。长时间查阅后，我找到了一些关键字指向了“捕获变量”和“锁定变量”。 这些短语就像是一滩浑水（对我来说），不是能完全清楚“捕获变量”或“锁定变量“的意思，知道我看到了”Plug“、”Seal“和”Cork“。 一瞬间茅塞顿开。 你可以想象一个场景需要你想想一个场景，把方法想象成一个空的泳池。就是一个Swwingpool.Empty 程序开始运行，之后同一时刻你的程序有很多方法执行了回调。当开始执行程序后，水涌入填充池子。一打硬币进入了水里。 硬币代表了变量，由方法也就是池子创建并使用。 方法执行了所有的return返回了关键字，并把所有的返回值排除了池子。毫秒级内，池子的水被吸出了。 当所有的硬币都在池子里会发生什么 当然，所有的变脸都会被冲走，所有的一切都像是没发生过，当方法执行了return，你的池子就被清空了。 当方法执行return，所有由方法创建的变量被清除除了内存。 除非…如果，池子里任然有水，你任然可以潜进去，扔下或者剑气一下硬币。如果你可以把他放在一个容器里，用软木塞或者其他容器密封。 如果你做了这个，这些硬币依然可以被使用，即时池子被排除了水（当方法执行了return）。 如果需要的话一个闭包可以被作为一种在池子里铲出硬币（变量或者容器）的机制，并密封它自己，知道超方法清空它和硬币。 闭包实践当你从官方文档得知 “self-contained blocks of functionality that can be passed around and used in your code.”，也许你会意识到这点，他们从环境中获取变量，打包并密封变量，来达到保护变量的目的。 事实证明，你创建的所有闭包都有这样的能力。 并不是所有的返回并锁定变量，但是Swift的所有闭包都有这样的功能。 这可能就是闭包为什么叫”闭包“吧。 ​ 好吧，我可能理解了作者的意思，但是比喻方法~不是很理解。]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的一天]]></title>
    <url>%2F2017%2F06%2F15%2F%E6%96%B0%E7%9A%84%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[UI小需求 根据返回数据加载类似朋友圈视图 思路：通过集合视图，根据返回字段内容实现对应的item类型，模型中计算UI应的高度属性。 但是在实现的时候遇到了小小的问题。 最开始使用的是xib实现，拖出NSLayoutConstraint并进行修改。 最怕但是，这个week引用的NSLayoutConstraint对象只能修改constant/multiplier属性。哪怕~重新制定新的NSLayoutConstraint对象都无济于事。。。虽然修改了对应的NSLayoutConstraint对象，但是确实没有更改布局。 好吧，按照快速开发的标准（“懒”），准备对应多的子类，子类的大小还是写死的。但是由NetWorkMananger根据数据决定采用哪种item。 通过加载的数据计算下，对应的item大小。 除了代码耦合度比较高之外，其他还是很满意的。 上传多组数组 需求：上传多组数据，在同一个页面内可能会多次上传。因此需要对比上传的数据源。 思路：记录当前已上传的数据，每次上传前对比数据。如果没有上传过则上传。 实现：因为将数据存放在数组中，因此转换成了NSSet对象对比出差集，上传差集数据。]]></content>
      <categories>
        <category>无聊</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客]]></title>
    <url>%2F2017%2F06%2F10%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[this article is just to test myblog ,welcome. 第一次动手去写Bolg，之前有个人和我说：为什么不写博客呢？ 当时的回答是不知道写什么，大多也就是参考他人的东西，拾人牙慧而已。 现在觉得也不是完全没必要，也算是激励自己的学习记录自己脚步的一种方式，恰好本人懒得写日记。]]></content>
      <categories>
        <category>无聊</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>